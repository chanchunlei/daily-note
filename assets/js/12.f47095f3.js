(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{570:function(s,e,t){s.exports=t.p+"assets/img/30083ef0a2ed6cbe2213e4ccb859f8b6.63af9d94.png"},586:function(s,e,t){"use strict";t.r(e);var a=t(17),r=Object(a.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h4",{attrs:{id:"defer-async-module-script"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer-async-module-script"}},[s._v("#")]),s._v(" defer/async/module （script）")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("defer/async\ndefer和async的机制都是异步（相较于HTML解析）加载js脚本，不同的是js脚本的执行时间；\n"),a("code",[s._v("defer")]),s._v("要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；而且是按照defer脚本的声明顺序来执行脚本的。\n"),a("code",[s._v("async")]),s._v("一旦下载完（下载完就执行），渲染引擎就会中断渲染，执行这个脚本之后，在继续渲染，多个async脚本是不能保证顺序的。\n"),a("img",{attrs:{src:t(570),alt:"30083ef0a2ed6cbe2213e4ccb859f8b6.png"}})])]),s._v(" "),a("li",[a("p",[s._v("module，\nmodule比较不一样是设置在type中"),a("code",[s._v('type="module"')]),s._v("，可以同时设置async和defer; 在现代浏览器中，我们可以声明acript标签type=’module’属性从而拥抱es6的模块导入导出语法，就像这样：")])])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("script type"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"module"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" Max "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"./math.js"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("Max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//7")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("blockquote",[a("p",[s._v("module默认使用了”use strict”模式，这也意味着不能使用诸如arguments.callee这一类的语法。\n模块只会加载一次，无论前后你写了多少次。\n不支持<!–const a = 1–>注释。\nmodule有自己的词法作用域，比如定义一个 var a = 1，并不会创建一个全局变量，因此你并不能通过window.a 访问到它的值。")])]),s._v(" "),a("h4",{attrs:{id:"预加载preload、prefetch、subresource、prerender-link"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预加载preload、prefetch、subresource、prerender-link"}},[s._v("#")]),s._v(" 预加载preload、prefetch、subresource、prerender （link）")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("preload\n使用 preload 可以对当前页面所需的脚本、样式等资源进行预加载，而无需等到解析到 script 和 link 标签时才进行加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。一旦启用后便会告知浏览器应该尽快的加载某个资源，如果提取的资源3s内未在当前使用，在谷歌开发工具将会触发警告消息。")])]),s._v(" "),a("li",[a("p",[s._v("prefetch\nprefetch 和 preload 一样，都是对资源进行预加载，但是 prefetch 一般预加载的是其他页面会用到的资源。\n当然，prefetch 不会像 preload 一样，在页面渲染的时候加载资源，而是利用浏览器空闲时间来下载。当进入下一页面，就可直接从 disk cache 里面取，既不影响当前页面的渲染，又提高了其他页面加载渲染的速度。")])]),s._v(" "),a("li",[a("p",[s._v("subresource\nsubresource 可以用来指定资源是当前页面资源的最高优先级，推荐使用 subresource。")])])]),s._v(" "),a("p",[s._v("-prerender\nprerender 是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。（谨慎使用）")])])}),[],!1,null,null,null);e.default=r.exports}}]);