(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{584:function(t,o,r){"use strict";r.r(o);var e=r(17),a=Object(e.a)({},(function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"基于原型的语言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于原型的语言"}},[t._v("#")]),t._v(" 基于原型的语言")]),t._v(" "),r("p",[t._v("JavaScript就是这种基于原型的语言，每个对象都有一个原型对象；对象以其原型为模板，从原型继承属性和方法。原型对象也可以拥有原型并从中继承属性和方法，一层一层，以此类推；这种关系被称为原型链，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。")]),t._v(" "),r("p",[t._v("准确的说这些属性和方法是定义在Object的构造器函数（constructor functions）之上的prototype属性上。而不是对象本身。")]),t._v(" "),r("blockquote",[r("p",[t._v("（可以通过Object.getPrototypeOf(obj)或者已被弃用的__proto__属性获得）同时与构造函数的prototype属性是有区别的。")])]),t._v(" "),r("h3",{attrs:{id:"prototype"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#prototype"}},[t._v("#")]),t._v(" prototype")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("每个函数都拥有的属性prototype；同时通过这个我们可以使用new字符创建一个实例，这个实例的__proto__属性就是原函数的prototype；而这个创建出来的函数也可以拥有自己的属性，同时继承了构造函数的prototype；当创建的函数在自身找不到某个属性的时候，就会在__proto__中找（也就是原函数的prototype中），如果还找不到，就会去原函数的__proto__中去找，一直下去，如果__proto__被找完了都没有，就会返回undefined。\n\n> prototype是继承成员被定义的地方，在这里以外的属性是不可被继承的\n> 我们可以通过Object.create()来指定新对象的原型属性\n")])])]),r("h3",{attrs:{id:"constructor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("每个实例对象都会从原型中继承一个constructor属性，这个属性指向该事例的构造函数。\n\n> fn.constructor.name可以获取到构造函数的名字")])])])])}),[],!1,null,null,null);o.default=a.exports}}]);